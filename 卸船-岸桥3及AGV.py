import math
import itertools
import time
import random
import pandas as pd
import csv
from itertools import zip_longest

# 假设岸桥上小车初始位置是轨道的最右端，并具有一定的z坐标
x_right = 200  # 岸桥上轨道最右端的x坐标
z_initial = 55  # 小车初始z坐标

# 小车移动速度（假设为恒定速度）
v_x_loaded = 5  # 满载时小车在x轴上的移动速度，单位：米/秒
v_x_unloaded = 5  # 空载时小车在x轴上的移动速度，单位：米/秒
v_z_load_down = 1.25  # 小车满载下行的速度，单位：米/秒
v_z_unload_down = 3  # 小车空载下行的速度，单位：米/秒
v_z_load_up = 1.25  # 小车满载上行的速度，单位：米/秒
v_z_unload_up = 3  # 小车满载上行的速度，单位：米/秒
v_qc_move = 0.75  # 岸桥做贝位移动，单位：米/秒

# 功率值
P_x_loaded_kW = 244.8  # 满载时岸桥小车功率，单位：千瓦（移动箱子）
P_x_unloaded_kW = 228  # 空载时岸桥小车功率，单位：千瓦（移动箱子）
P_down_load_kW = 244.8  # 小车下行满载功率，单位：千瓦
P_down_unloaded_kW = 228  # 小车下行空载功率，单位：千瓦
P_up_load_kW = 244.8  # 小车上行满载功率，单位：千瓦
P_up_unload_kW = 228  # 小车上行空载功率，单位：千瓦
P_qc_move = 228  # 岸桥空载做贝位移动，单位：千瓦
agvWait = (0, 0, 0)
# 功率值
P_AGV_UNLOAD = 3.1  # AGV空载功率
P_AGV_LOAD = 3.3  # AGV满载功率
P_AGV_RELAX = 1
# 由集装箱随机生成.py生成，包含多个集装箱的空间坐标
unload_positions = [
    (259.6, -69.6, 25.0),
    (262.7, -69.6, 25.0),
    (264.2, -69.6, 25.0),
    (268.8, -69.6, 25.0),
    (270.9, -69.6, 25.0),
    (273.7, -69.6, 25.0),
    (275.9, -69.6, 25.0),
    (281.0, -69.6, 25.0),
    (283.0, -69.6, 25.0),
    (284.5, -69.6, 25.0),
    (287.3, -69.6, 25.0),
    (292.6, -69.6, 25.0),
    (293.4, -69.6, 25.0),
    (298.3, -69.6, 25.0),
    (299.3, -69.6, 25.0),
    (303.5, -69.6, 25.0),
    (305.9, -69.6, 25.0),
    (308.3, -69.6, 25.0),
    (312.0, -69.6, 25.0),
    (315.5, -69.6, 25.0),
    (318.3, -69.6, 25.0),
    (320.9, -69.6, 25.0),
    (324.1, -69.6, 25.0),
    (325.5, -69.6, 25.0),
    (329.1, -69.6, 25.0),
    (331.6, -69.6, 25.0),
    (335.4, -69.6, 25.0),
    (336.7, -69.6, 25.0),
    (340.4, -69.6, 25.0),
    (344.6, -69.6, 25.0),
    (345.7, -69.6, 25.0),
    (349.2, -69.6, 25.0),
    (352.4, -69.6, 25.0),
    (355.2, -69.6, 25.0),
    (359.3, -69.6, 25.0),
    (360.8, -69.6, 25.0),
    (364.0, -69.6, 25.0),
    (367.0, -69.6, 25.0),
    (368.5, -69.6, 25.0),
    (372.7, -69.6, 25.0),
    (375.4, -69.6, 25.0),
    (378.5, -69.6, 25.0),
    (381.2, -69.6, 25.0),
    (384.5, -69.6, 25.0),
    (386.7, -69.6, 25.0),
    (390.9, -69.6, 25.0),
    (393.0, -69.6, 25.0),
    (396.6, -69.6, 25.0),
    (398.8, -69.6, 25.0),
    (401.0, -69.6, 25.0),
    (404.3, -69.6, 25.0),
    (408.3, -69.6, 25.0),
    (409.2, -69.6, 25.0),
    (413.7, -69.6, 25.0),
    (416.5, -69.6, 25.0),
    (418.8, -69.6, 25.0),
    (421.0, -69.6, 25.0),
    (425.7, -69.6, 25.0),
    (429.0, -69.6, 25.0),
    (430.4, -69.6, 25.0),
    (432.9, -69.6, 25.0),
    (435.8, -69.6, 25.0),
    (438.3, -69.6, 25.0),
    (442.5, -69.6, 25.0),
    (445.2, -69.6, 25.0),
    (446.8, -69.6, 25.0),
    (450.2, -69.6, 25.0),
    (453.5, -69.6, 25.0),
    (259.0, -56.7, 27.6),
    (262.5, -56.7, 27.6),
    (264.6, -56.7, 27.6),
    (269.2, -56.7, 27.6),
    (270.9, -56.7, 27.6),
    (273.2, -56.7, 27.6),
    (277.1, -56.7, 27.6),
    (278.8, -56.7, 27.6),
    (283.6, -56.7, 27.6),
    (284.7, -56.7, 27.6),
    (289.4, -56.7, 27.6),
    (291.6, -56.7, 27.6),
    (294.3, -56.7, 27.6),
    (296.4, -56.7, 27.6),
    (300.9, -56.7, 27.6),
    (302.7, -56.7, 27.6),
    (305.3, -56.7, 27.6),
    (307.8, -56.7, 27.6),
    (311.5, -56.7, 27.6),
    (314.7, -56.7, 27.6),
    (316.8, -56.7, 27.6),
    (321.6, -56.7, 27.6),
    (323.0, -56.7, 27.6),
    (327.0, -56.7, 27.6),
    (329.7, -56.7, 27.6),
    (332.9, -56.7, 27.6),
    (336.2, -56.7, 27.6),
    (338.5, -56.7, 27.6),
    (340.4, -56.7, 27.6),
    (342.9, -56.7, 27.6),
    (346.8, -56.7, 27.6),
    (350.1, -56.7, 27.6),
    (352.1, -56.7, 27.6),
    (355.9, -56.7, 27.6),
    (358.0, -56.7, 27.6),
    (361.7, -56.7, 27.6),
    (364.2, -56.7, 27.6),
    (366.1, -56.7, 27.6),
    (369.7, -56.7, 27.6),
    (373.1, -56.7, 27.6),
    (374.5, -56.7, 27.6),
    (378.6, -56.7, 27.6),
    (381.2, -56.7, 27.6),
    (384.8, -56.7, 27.6),
    (387.0, -56.7, 27.6),
    (389.4, -56.7, 27.6),
    (392.3, -56.7, 27.6),
    (395.2, -56.7, 27.6),
    (399.5, -56.7, 27.6),
    (401.7, -56.7, 27.6),
    (403.9, -56.7, 27.6),
    (407.1, -56.7, 27.6),
    (411.5, -56.7, 27.6),
    (412.9, -56.7, 27.6),
    (416.6, -56.7, 27.6),
    (419.2, -56.7, 27.6),
    (421.3, -56.7, 27.6),
    (424.7, -56.7, 27.6),
    (428.0, -56.7, 27.6),
    (429.5, -56.7, 27.6),
    (433.1, -56.7, 27.6),
    (436.6, -56.7, 27.6),
    (439.8, -56.7, 27.6),
    (441.8, -56.7, 27.6),
    (444.2, -56.7, 27.6),
    (448.4, -56.7, 27.6),
    (450.9, -56.7, 27.6),
    (452.7, -56.7, 27.6),
    (260.1, -43.8, 30.2),
    (262.6, -43.8, 30.2),
    (266.2, -43.8, 30.2),
    (268.7, -43.8, 30.2),
    (270.7, -43.8, 30.2),
    (274.6, -43.8, 30.2),
    (276.1, -43.8, 30.2),
    (280.1, -43.8, 30.2),
    (283.3, -43.8, 30.2),
    (286.3, -43.8, 30.2),
    (287.5, -43.8, 30.2),
    (290.9, -43.8, 30.2),
    (293.9, -43.8, 30.2),
    (296.4, -43.8, 30.2),
    (300.8, -43.8, 30.2),
    (303.1, -43.8, 30.2),
    (306.4, -43.8, 30.2),
    (308.9, -43.8, 30.2),
    (310.9, -43.8, 30.2),
    (314.2, -43.8, 30.2),
    (317.7, -43.8, 30.2),
    (320.9, -43.8, 30.2),
    (323.7, -43.8, 30.2),
    (327.2, -43.8, 30.2),
    (329.7, -43.8, 30.2),
    (330.9, -43.8, 30.2),
    (334.3, -43.8, 30.2),
    (338.6, -43.8, 30.2),
    (340.7, -43.8, 30.2),
    (344.3, -43.8, 30.2),
    (347.6, -43.8, 30.2),
    (348.7, -43.8, 30.2),
    (352.0, -43.8, 30.2),
    (355.7, -43.8, 30.2),
    (358.4, -43.8, 30.2),
    (360.3, -43.8, 30.2),
    (364.0, -43.8, 30.2),
    (366.7, -43.8, 30.2),
    (370.1, -43.8, 30.2),
    (371.6, -43.8, 30.2),
    (375.8, -43.8, 30.2),
    (378.4, -43.8, 30.2),
    (381.1, -43.8, 30.2),
    (385.4, -43.8, 30.2),
    (387.3, -43.8, 30.2),
    (389.2, -43.8, 30.2),
    (392.2, -43.8, 30.2),
    (394.7, -43.8, 30.2),
    (397.7, -43.8, 30.2),
    (400.6, -43.8, 30.2),
    (403.4, -43.8, 30.2),
    (407.8, -43.8, 30.2),
    (410.1, -43.8, 30.2),
    (413.3, -43.8, 30.2),
    (416.8, -43.8, 30.2),
    (418.1, -43.8, 30.2),
    (421.8, -43.8, 30.2),
    (424.4, -43.8, 30.2),
    (428.6, -43.8, 30.2),
    (429.5, -43.8, 30.2),
    (432.8, -43.8, 30.2),
    (435.4, -43.8, 30.2),
    (440.2, -43.8, 30.2),
    (442.2, -43.8, 30.2),
    (444.4, -43.8, 30.2),
    (446.9, -43.8, 30.2),
    (260.7, -30.9, 32.8),
    (263.3, -30.9, 32.8),
    (266.5, -30.9, 32.8),
    (267.1, -30.9, 32.8),
    (272.3, -30.9, 32.8),
    (272.9, -30.9, 32.8),
    (276.2, -30.9, 32.8),
    (280.2, -30.9, 32.8),
    (281.8, -30.9, 32.8),
    (286.2, -30.9, 32.8),
    (289.5, -30.9, 32.8),
    (292.6, -30.9, 32.8),
    (294.1, -30.9, 32.8),
    (297.1, -30.9, 32.8),
    (301.4, -30.9, 32.8),
    (303.9, -30.9, 32.8),
    (305.2, -30.9, 32.8),
    (310.0, -30.9, 32.8),
    (311.8, -30.9, 32.8),
    (314.0, -30.9, 32.8),
    (317.0, -30.9, 32.8),
    (320.1, -30.9, 32.8),
    (322.9, -30.9, 32.8),
    (325.7, -30.9, 32.8),
    (330.1, -30.9, 32.8),
    (332.7, -30.9, 32.8),
    (335.6, -30.9, 32.8),
    (338.4, -30.9, 32.8),
    (340.2, -30.9, 32.8),
    (344.6, -30.9, 32.8),
    (347.4, -30.9, 32.8),
    (349.6, -30.9, 32.8),
    (351.7, -30.9, 32.8),
    (354.2, -30.9, 32.8),
    (358.4, -30.9, 32.8),
    (361.9, -30.9, 32.8),
    (364.8, -30.9, 32.8),
    (367.8, -30.9, 32.8),
    (371.0, -30.9, 32.8),
    (372.4, -30.9, 32.8),
    (375.2, -30.9, 32.8),
    (378.5, -30.9, 32.8),
    (382.6, -30.9, 32.8),
    (383.7, -30.9, 32.8),
    (387.9, -30.9, 32.8),
    (389.1, -30.9, 32.8),
    (392.3, -30.9, 32.8),
    (395.3, -30.9, 32.8),
    (398.0, -30.9, 32.8),
    (402.0, -30.9, 32.8),
    (404.2, -30.9, 32.8),
    (407.1, -30.9, 32.8),
    (410.1, -30.9, 32.8),
    (414.2, -30.9, 32.8),
    (416.6, -30.9, 32.8),
    (419.3, -30.9, 32.8),
    (421.0, -30.9, 32.8),
    (426.0, -30.9, 32.8),
    (427.5, -30.9, 32.8),
    (430.6, -30.9, 32.8),
    (432.9, -30.9, 32.8),
    (435.5, -30.9, 32.8),
    (438.7, -30.9, 32.8),
    (441.5, -30.9, 32.8),
    (445.8, -30.9, 32.8),
    (258.7, -18.0, 35.4),
    (263.1, -18.0, 35.4),
    (265.3, -18.0, 35.4),
    (269.5, -18.0, 35.4),
    (271.3, -18.0, 35.4),
    (272.9, -18.0, 35.4),
    (276.3, -18.0, 35.4),
    (281.0, -18.0, 35.4),
    (282.8, -18.0, 35.4),
    (285.5, -18.0, 35.4),
    (288.8, -18.0, 35.4),
    (291.1, -18.0, 35.4),
    (294.9, -18.0, 35.4),
    (298.3, -18.0, 35.4),
    (301.2, -18.0, 35.4),
    (303.5, -18.0, 35.4),
    (304.9, -18.0, 35.4),
    (309.4, -18.0, 35.4),
    (310.6, -18.0, 35.4),
    (314.4, -18.0, 35.4),
    (318.7, -18.0, 35.4),
    (321.2, -18.0, 35.4),
    (323.2, -18.0, 35.4),
    (325.4, -18.0, 35.4),
    (329.1, -18.0, 35.4),
    (331.6, -18.0, 35.4),
    (335.6, -18.0, 35.4),
    (337.8, -18.0, 35.4),
    (340.3, -18.0, 35.4),
    (344.0, -18.0, 35.4),
    (346.0, -18.0, 35.4),
    (349.8, -18.0, 35.4),
    (352.7, -18.0, 35.4),
    (356.3, -18.0, 35.4),
    (358.6, -18.0, 35.4),
    (361.8, -18.0, 35.4),
    (364.4, -18.0, 35.4),
    (366.9, -18.0, 35.4),
    (371.0, -18.0, 35.4),
    (373.6, -18.0, 35.4),
    (375.8, -18.0, 35.4),
    (378.6, -18.0, 35.4),
    (381.7, -18.0, 35.4),
    (384.1, -18.0, 35.4),
    (387.1, -18.0, 35.4),
    (389.6, -18.0, 35.4),
    (394.0, -18.0, 35.4),
    (394.9, -18.0, 35.4),
    (399.7, -18.0, 35.4),
    (401.2, -18.0, 35.4),
    (405.3, -18.0, 35.4),
    (407.9, -18.0, 35.4),
    (410.9, -18.0, 35.4),
    (412.4, -18.0, 35.4),
    (415.9, -18.0, 35.4),
    (419.4, -18.0, 35.4),
    (422.6, -18.0, 35.4),
    (425.4, -18.0, 35.4),
    (428.6, -18.0, 35.4),
    (431.5, -18.0, 35.4),
]

data_list = []  # excel输出


# 生成器函数，用于产生指定数量的随机排列，每个排列内部按 z 值降序排列
def generate_random_permutations(positions, num_permutations):
    for _ in range(num_permutations):
        # 创建当前 positions 列表的一个副本，并随机打乱它的顺序
        shuffled_positions = positions.copy()
        random.shuffle(shuffled_positions)

        # 对打乱后的列表进行排序，按 z 值的降序排列
        shuffled_positions.sort(key=lambda pos: pos[2], reverse=True)

        # 产出排列
        yield shuffled_positions

    # 设置你想要生成的排列数量


num_permutations_to_generate = 100

total_time_agvstart = 0
# 记录岸桥贝位移动时间和能源
t_qc_move = 0
energy_qc_move = 0

# 初始化上一个y坐标的变量，用于操作两个箱子之间计算岸桥贝位移动
previous_y = None

# 记录循环开始的时间
start_time = time.time()

# 设置循环运行的时间限制（秒）
time_limit = 30000

#  初始化运行时间
elapsed_time = 0
total_energies_kWhs = []
total_times_ss = []
total_time_agvstarts = []
# 初始化计数器和循环条件
count = 0

# AGV 参数（这些参数应根据您的实际情况进行调整）
v_agv_unload = 5.55  # AGV空载移动速度 (m/s)
v_agv_load = 5.2  # AGV满载移动速度 (m/s)


# 计算两点之间的距离
def calculate_distance(pos1, pos2):
    return math.sqrt((pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2)


s = 0
yard_crane_positions = [
    (0, -225),
    (0, -275),
    (0, -325)
]  # 场桥位置列表

# 按生成的箱子顺序迭代器做方案循环
for permutation in generate_random_permutations(unload_positions, num_permutations_to_generate):
    order = list(permutation)  # 将元组转换为列表（这一步其实是不必要的，因为permutation已经是一个元组列表）
    # 打印当前岸桥工作方案
    print("----start------")
    print(f"第一个岸桥工作顺序：{order}")
    # 在循环体内增加计数器的值
    count += 1
    # 在每次外层循环开始时，初始化两个临时列表来存储本次循环的数据
    total_energies_kWh = []
    total_times_s = []
    energy_move1_kWh = 0
    energy_down_kWh = 0
    energy_up_kWh = 0
    energy_move2_kWh = 0
    energy_down2_kWh = 0
    energy_up2_kWh = 0
    t_s_down2 = 0
    t_s_move = 0
    t_s_up2 = 0
    t_s_down = 0
    t_qc_move = 0
    t_s_up = 0
    t_s_move2 = 0
    energy_qc_move = 0
    # 初始化总能耗和总时间
    total_energy_kWh = 0
    total_time_s = 0
    # 遍历每个需要卸载的箱子坐标
    for position in permutation:
        s += 1
        x_unload, y_unload, z_unload = position
        # 计算小车从初始位置到箱子位置的水平距离（假设只在x轴上移动）
        L_m = abs(x_right - x_unload)  # 单位：米

        # 第一步：计算水平移动时间和能耗
        t_s_move = L_m / v_x_unloaded  # 单位：秒
        energy_move1_kWh = P_x_unloaded_kW * (t_s_move / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_move1_kWh)
        total_times_s.append(t_s_move)

        # 第二步：计算小车下行抓箱子的时间和能耗
        z_distance = z_initial - z_unload  # 计算下行距离
        t_s_down = z_distance / v_z_unload_down  # 单位：秒
        energy_down_kWh = P_down_unloaded_kW * (t_s_down / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_down_kWh)
        total_times_s.append(t_s_down)

        # 第三步：计算小车抓箱子后上行的时间和能耗
        t_s_up = z_distance / v_z_unload_up  # 单位：秒
        energy_up_kWh = P_up_load_kW * (t_s_up / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_up_kWh)
        total_times_s.append(t_s_up)

        # 第四步：计算载货水平移动时间和能耗
        t_s_move2 = L_m / v_x_loaded  # 单位：秒
        energy_move2_kWh = P_x_loaded_kW * (t_s_move2 / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_move2_kWh)
        total_times_s.append(t_s_move2)

        # 第五步：计算小车抓箱子后下行的时间和能耗
        t_s_down2 = z_initial / v_z_load_down  # 单位：秒
        energy_down2_kWh = P_down_load_kW * (t_s_down2 / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_down2_kWh)
        total_times_s.append(t_s_down2)

        # 第六步：计算回归原位时间和能耗
        t_s_up2 = z_initial / v_z_unload_up  # 单位：秒
        energy_up2_kWh = P_up_unload_kW * (t_s_up2 / 3600)  # 单位：千瓦时
        total_energies_kWh.append(energy_up2_kWh)
        total_times_s.append(t_s_up2)

        # agv送集装箱场桥
        quay_crane_index = s % 3  # 使用取模来选择岸桥
        yard_crane_index = s % len(yard_crane_positions)  # 使用取模来选择场桥

        quay_crane_pos = unload_positions[quay_crane_index]
        yard_crane_pos = yard_crane_positions[yard_crane_index]

        # agv从等待区到岸桥的距离和时间
        distance_to_yc = calculate_distance(quay_crane_pos, agvWait)
        time_to_yc2 = distance_to_yc / v_agv_unload
        e_to_yc2 = P_AGV_UNLOAD * (time_to_yc2 / 3600)  # 单位：千瓦时

        # 从岸桥到场桥的距离和时间
        distance_to_yc = calculate_distance(quay_crane_pos, yard_crane_pos)
        time_to_yc = distance_to_yc / v_agv_load
        e_to_yc = P_AGV_LOAD * (time_to_yc / 3600)  # 单位：千瓦时

        # 第九步：AGV等待场桥时间
        z_distance = 18
        t_s_down = z_distance / v_z_unload_down  # 单位：秒
        t_s_up = z_distance / v_z_load_up
        t4 = t_s_down + t_s_up
        energy_agv4 = P_AGV_RELAX * (t4 / 3600)

        # 第十步：AGV返回等待区时间
        L_v = calculate_distance(yard_crane_pos, agvWait)
        t5 = L_v / v_agv_unload
        energy_agv5 = P_AGV_UNLOAD * (t5 / 3600)  # 单位：千瓦时

        # 第七步：计算贝位移动时间和能耗
        if previous_y is not None:
            # 计算当前y坐标与上一个y坐标的差值
            difference = abs(y_unload - previous_y)
            if difference != 0:
                t_qc_move = abs(difference) / v_qc_move  # 单位：秒
                energy_qc_move = P_qc_move * (t_qc_move / 3600)  # 单位：千瓦时
                total_energy_kWh += energy_qc_move
                total_time_s += t_qc_move
                total_energies_kWh.append(energy_qc_move + e_to_yc + energy_agv4 + energy_agv5 + e_to_yc2)
                total_times_s.append(t_qc_move)
        # 更新上一个y坐标的值
        previous_y = y_unload
        total_energy_kWh += (energy_move1_kWh + energy_down_kWh + energy_up_kWh + energy_move2_kWh + energy_down2_kWh +
                             energy_up2_kWh + energy_qc_move)
        total_time_s += t_s_move + t_s_down + t_s_up + t_s_move2 + t_s_down2 + t_s_up2 + t_qc_move
        # 打印调试信息（可选）
        # print(f"当工作下个箱子需要调整岸桥y轴上的距离：{difference}m")
        # print(f"计算岸桥贝位移动时间：{t_qc_move:.2f} 秒，能耗：{energy_qc_move:.2f} 千瓦时")
        # 输出每一步的能耗和时间
        print(f"---当前工作箱子坐标：({x_unload}, {y_unload}, {z_unload})")
        print(f"第一步（岸桥小车向左水平移动）时间：{t_s_move:.2f} 秒，能耗：{energy_move1_kWh:.2f} 千瓦时")
        print(f"第二步（小车下行抓箱子）时间：{t_s_down:.2f} 秒，能耗：{energy_down_kWh:.2f} 千瓦时")
        print(f"第三步（小车载箱子上行）时间：{t_s_up:.2f} 秒，能耗：{energy_up_kWh:.2f} 千瓦时")
        print(f"第四步（岸桥小车向右水平移动）时间：{t_s_move:.2f} 秒，能耗：{energy_move2_kWh:.2f} 千瓦时")
        print(f"第五步（小车载箱子下行）时间：{t_s_down2:.2f} 秒，能耗：{energy_down2_kWh:.2f} 千瓦时")
        print(f"第六步（小车空载上行回归原位）时间：{t_s_up2:.2f} 秒，能耗：{energy_up2_kWh:.2f} 千瓦时")
        print(f"第七步（岸桥做贝位移动时间）：{t_qc_move:.2f} 秒，能耗：{energy_qc_move:.2f} 千瓦时")
    total_energies_kWhs.extend(total_energies_kWh)
    total_times_ss.extend(total_times_s)
    total_energies_kWh.clear()
    total_times_s.clear()
    # 初始化变量每60min
    total_time = 0.0  # 累计时间
    total_energy = 0.0  # 当前小时的能源总和
    print(f"----0-23个时间段，每个时间段的能耗----")
    # 遍历时间和能源列表
    for times, energy in zip(total_times_ss, total_energies_kWhs):
        # 累加时间
        total_time += times
        # 累加能源
        total_energy += energy
        # 检查是否达到或超过1小时（3600秒）
        if total_time >= 3600:
            # 输出当前小时的能源和
            print(f"------{total_energy:.2f}------")
            data_list.append(total_energy)
            # 重置时间和能源总和为剩余部分（如果有的话）
            remaining_time = total_time - math.floor(total_time / 3600) * 3600
            total_time = remaining_time
            total_energy = 0.0 if remaining_time == 0.0 else total_energies_kWhs[
                total_energies_kWhs.index(energy) + 1]  # 假设下一个能源值是当前小时剩余时间的能源

    if total_time > 0:
        print(f"未满1h部分: {total_energy}")
        data_list.append(total_energy)
    print(f"----岸桥小车卸载所有箱子所需的总能耗是：{total_energy_kWh:.2f} 千瓦时-----")
    print(f"----岸桥小车卸载所有箱子所需的总运输时间是：{total_time_s:.2f} 秒-----")
    print(f"----岸桥工作开始时间：{0}   岸桥工作结束时间：{total_time_s:.2f} 秒----")
    total_energies_kWhs.clear()
    total_times_ss.clear()
    # 检查是否已经超过了时间限制
    current_time = time.time()
    elapsed_time = current_time - start_time
    if elapsed_time >= time_limit:
        break  # 如果已经超过了时间限制，跳出循环
# 输出最终结果包含方案个数.运行时间.总能耗和总时间
print("循环已停止，代码总共运行了 {} 秒".format(elapsed_time))
print(f"-------------共有方案个数: {count} ---------------------------")
# -----------------打印---------------------------------
# 确定每列包含的元素数量
elements_per_column = 13
# 准备一个空的DataFrame
df = pd.DataFrame()
# 计算需要的列数
num_columns = len(data_list) // elements_per_column
# 遍历列表，将数据添加到DataFrame中
for i in range(num_columns):
    # 计算当前列在列表中的起始和结束索引
    start_index = i * elements_per_column
    end_index = start_index + elements_per_column

    # 提取当前列的数据
    column_data = data_list[start_index:end_index]

    # 如果当前列的数据长度不足12个，用None填充到12个
    if len(column_data) < elements_per_column:
        column_data.extend([None] * (elements_per_column - len(column_data)))

        # 将当前列的数据添加到DataFrame中
    df[f'方案{i + 1}'] = column_data

# 将DataFrame写入Excel文件
df.to_excel('岸桥3及AGV能耗.xlsx', index=False, engine='openpyxl')